Solves sorting problem from chapter 1, CRSV
input: A sequence of n numbers (a1, a2, ...., an)
Output: A permutation (reordering) (a'1, a'2, ....,a'n) of the input sequence such that a'1<=a'2<=....a'n

The following will be written in psuedocode

INSERTION-SORT(A) psuedocode
A = [5, 2, 4, 6, 1, 3]
for j = 2 to A.length
  key = A[j]
   insert A[j] into the sorted sequence A[1..j - 1]
  i = j - 1
  while i > 0 and A[i] > key
    A[i+1] = A[i]
    i = i - 1
  A[i+1] = key

INTEGER MULTIPLICATION vs 
Input: Two n-digit numbers x and y
Output: The product x * y

"Primitive Operation": adding or multiplpying 2 single-digit numbers
 5678
x1234
7006652
Upshot: n^2 -- Grows larger at a constant rate as numbers grow larger



KARATSUBA MULTIPLICATION
  5678
x 1234

a = 56
b = 78
c = 12
d = 34

1) a * c = 672
2) b * d = 2652
3) (a+b)(c+d) = 6164
4)  step 3 - step 2 - step 1 = 2840
5) 6720000 + 2652 + 284000 = 7006652

A RECURCIVE ALGORITHM
Write x = 10^n/2a+b and y = 10^n/2c+d
where a,b,c,d are n/2-digit numbers
Example: a = 56, b = 78, c = 12, d = 34

Then: x*y = (10^n/2a+b) * (10^n/2c+d)
 = 10^nac + 10^n/2(ad + bc) + bd (called *)
This assumes that n is even, can pursue odds similar (9 into group of 5 and 4)
Idea: Recursively compute ac, ad, bc, bd, then compute * in a straightforward way
(simple base case missing)

Remembering *, can we write this using 3 recursive calls?:
1) Recursively compute ac
2) Recursively compute bd
3) Recursively compute (a+b)(c+d) = ac + ad + bc + bd
Gauss's trick:
3 - 1 - 2 = ad + bc
Upshot: only need 3 recursive multiplactions! (and some additions)
